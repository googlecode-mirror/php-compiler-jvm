%{
    #include <conio.h>
    #include <string.h>
	#include "bison_input.yacc_tab.h"
	#define PHP_DEBUG

	int start_condition[64];
	int condition_num = 0;
    char docName[64];
    char lexem[256];
	char html[512] = "";
#ifdef PHP_DEBUG
	char comment[512] = "";
#endif
	void beginCondition();
	void changeStartCondition(int condition);
	void addStartCondition(int condition);
	void returnStartCondition();
	void debugyy(char* msg, char* txt);
	void debug_clear(char* com);
	void debug_strcat(char* com, char* txt);
	void writeIntToUnion(char* num, char* base);
	void writeBinToUnion(char* num);
	void writeCharToUnion(char* const_char);
	void writeIdToUnion(char* id);
	void writeHtmlToUnion(char* uhtml);
	void printLex(char* lexemName, char* txt);
	void getDocName();
	int docNameCheck(char* name, char* txt);
	int strToNumber(char* num, char* base);
	int strToBin(char* num);
	void strcat_code(char* lex, int code);
	void strcat_strcode(char* lex, char* code);
	
	extern union YYSTYPE yylval;
%}
%option noyywrap
%option never-interactive

OCT_DIGIT [0-7]
HEX_DIGIT [0-9a-fA-F]
DEC_NUM [1-9][0-9]*|0
OCT_NUM 0[0-7]+
HEX_NUM 0[xX][0-9a-fA-F]+
BIN_NUM 0b[01]+
FIRST_SYMBOL [a-zA-Z_\x7f-\xff]
SYMBOL [a-zA-Z0-9_\x7f-\xff]
ID {FIRST_SYMBOL}{SYMBOL}*

%x PHP
%x STR
%x STR_SINGLE_QUOTATION
%x HEREDOC
%x NOWDOC
%x COMMENT
%x VAR
%x COMPLEX_VAR
%x VAR_BEGIN
%x COMPLEX_VAR_BEGIN
%x VAR_ARROW
%x VAR_INDEX
%x VAR_INDEX_BEGIN
%x VAR_INDEX_EXPR
%x VAR1
%x VAR2

%%

"<?"php {if (strlen(html) != 0) {writeHtmlToUnion(html);} beginCondition(); addStartCondition(PHP); return HTML;}
<PHP>"?>" {returnStartCondition();}

. strcat(html, yytext);
\n strcat(html, yytext);
<INITIAL><<EOF>> {if (strlen(html) != 0) {writeHtmlToUnion(html);} return HTML;}

<PHP>"<<<"{ID}|(\"{ID}\")$ {getDocName(); strcpy(lexem, ""); addStartCondition(HEREDOC);}
<PHP>"<<<"\'{ID}\'$ {getDocName(); strcpy(lexem, ""); addStartCondition(NOWDOC);}
<PHP>\" {strcpy(lexem, ""); addStartCondition(STR);}
<PHP>\' {strcpy(lexem, ""); addStartCondition(STR_SINGLE_QUOTATION);}

<HEREDOC,NOWDOC>^{ID};?$ {if (docNameCheck(docName, yytext)) {writeCharToUnion(lexem); returnStartCondition(); return CHAR_CONST;} else strcat(lexem, yytext);}
<STR>\" {writeCharToUnion(lexem); returnStartCondition(); return CHAR_CONST;}
<STR_SINGLE_QUOTATION>\' {writeCharToUnion(lexem); returnStartCondition(); return CHAR_CONST;}

<HEREDOC,STR>\${ID} {writeCharToUnion(lexem); strcpy(lexem, yytext+1); unput('1'); addStartCondition(VAR1); return CHAR_CONST;}
<HEREDOC,STR>\{\${ID} {writeCharToUnion(lexem); strcpy(lexem, yytext+2); unput('2'); addStartCondition(VAR1); return CHAR_CONST;}
<HEREDOC,STR>\$\{{ID} {writeCharToUnion(lexem); strcpy(lexem, yytext+2); unput('2'); addStartCondition(VAR1); return CHAR_CONST;}
<VAR1>. {unput(yytext[0]); changeStartCondition(VAR2); return '.';}
<VAR2>. {writeIdToUnion(lexem); if (yytext[0] == '1') changeStartCondition(VAR_BEGIN); else changeStartCondition(COMPLEX_VAR_BEGIN); return VARNAME;}
<COMPLEX_VAR>\} {returnStartCondition();}

<COMPLEX_VAR>"->" {addStartCondition(VAR_ARROW); return ARROW;}
<VAR_ARROW>{ID} {writeIdToUnion(yytext); returnStartCondition(); return ID;}

<COMPLEX_VAR,VAR>\[ {addStartCondition(VAR_INDEX_BEGIN); return '[';}
<VAR_INDEX_BEGIN>{ID} {writeIdToUnion(yytext); changeStartCondition(VAR_INDEX); return ID;}
<VAR_INDEX_BEGIN>{DEC_NUM} {writeIntToUnion(yytext, "%d"); changeStartCondition(VAR_INDEX); return INT_CONST;}
<VAR_INDEX>\] {returnStartCondition(); return ']';}
<VAR_INDEX>"+" {addStartCondition(VAR_INDEX_EXPR); return '+';}
<VAR_INDEX>"-" {addStartCondition(VAR_INDEX_EXPR); return '-';}
<VAR_INDEX>"*" {addStartCondition(VAR_INDEX_EXPR); return '*';}
<VAR_INDEX>"/" {addStartCondition(VAR_INDEX_EXPR); return '/';}
<VAR_INDEX>"%" {addStartCondition(VAR_INDEX_EXPR); return '%';}
<VAR_INDEX>"." {addStartCondition(VAR_INDEX_EXPR); return '.';}
<VAR_INDEX_EXPR>{ID} {writeIdToUnion(yytext); returnStartCondition(); return ID;}
<VAR_INDEX_EXPR>{DEC_NUM} {writeIntToUnion(yytext, "%d"); returnStartCondition(); return INT_CONST;}

<VAR>. {unput(yytext[0]); returnStartCondition();}

<HEREDOC,STR,NOWDOC,STR_SINGLE_QUOTATION>. strcat(lexem, yytext);
<HEREDOC,STR,NOWDOC,STR_SINGLE_QUOTATION>\n strcat(lexem, yytext);
<HEREDOC,STR,STR_SINGLE_QUOTATION>\\\\ strcat(lexem, "\\");
<STR_SINGLE_QUOTATION>\\\' strcat(lexem, "'");
<STR>\\\" strcat(lexem, "\"");
<HEREDOC,STR>\\n strcat(lexem, "\n");
<HEREDOC,STR>\\r strcat(lexem, "\r");
<HEREDOC,STR>\\t strcat(lexem, "\t");
<HEREDOC,STR>\\v strcat(lexem, "\v");
<HEREDOC,STR>\\f strcat(lexem, "\f");
<HEREDOC,STR>\\\$ strcat(lexem, "$");
<HEREDOC,STR>\\e strcat_code(lexem, 27);
<HEREDOC,STR>\\{OCT_DIGIT}{1,3} strcat_strcode(lexem, yytext);
<HEREDOC,STR>\\x{HEX_DIGIT}{1,2} strcat_strcode(lexem, yytext);

<PHP>"//".*

<PHP>"/*" {BEGIN(COMMENT);}
<COMMENT>"*/" {BEGIN(PHP);}
<COMMENT>.
<COMMENT>\n

<PHP>{DEC_NUM} {writeIntToUnion(yytext, "%d"); return INT_CONST;}
<PHP>{OCT_NUM} {writeIntToUnion(yytext, "%o"); return INT_CONST;}
<PHP>{HEX_NUM} {writeIntToUnion(yytext, "%x"); return INT_CONST;}
<PHP>{BIN_NUM} {writeBinToUnion(yytext); return INT_CONST;}

<PHP>true {yylval.intConstUnionType = 1; return BOOL_CONST;}
<PHP>false {yylval.intConstUnionType = 0; return BOOL_CONST;}

<PHP>array {return ARRAY;}

<PHP>if {return IF;}
<PHP>else {return ELSE;}
<PHP>elseif {return ELSEIF;}
<PHP>switch {return SWITCH;}
<PHP>case {return CASE;}
<PHP>break {return BREAK;}
<PHP>default {return DEFAULT;}

<PHP>for {return FOR;}
<PHP>foreach {return FOREACH;}
<PHP>as {return AS;}
<PHP>do {return DO;}
<PHP>while {return WHILE;}

<PHP>new {return NEW;}
<PHP>class {return CLASS;}
<PHP>this {return THIS;}
<PHP>extends {return EXTENDS;}
<PHP>var {return PUBLIC;}
<PHP>public {return PUBLIC;}
<PHP>private {return PRIVATE;}
<PHP>protected {return PROTECTED;}
<PHP>static {return STATIC;}
<PHP>parent {return PARENT;}

<PHP>function {return FUNCTION;}
<PHP>return {return RETURN;}

<PHP>echo {return ECHO;}
<PHP>print {return ECHO;}

<PHP>\${ID} {writeIdToUnion(yytext); return VARNAME;}
<PHP>{ID} {writeIdToUnion(yytext); return ID;}

<PHP>\( {return (unsigned char)'(';}
<PHP>\) {return (unsigned char)')';}
<PHP>\[ {return (unsigned char)'[';}
<PHP>\] {return (unsigned char)']';}
<PHP>\{ {return (unsigned char)'{';}
<PHP>\} {return (unsigned char)'}';}

<PHP>=> {return SETVALUE;}
<PHP>-> {return ARROW;}
<PHP>\. {return (unsigned char)'.';}
<PHP>: {return (unsigned char)':';}
<PHP>:: {return SCOPEOP;}

<PHP>, {return (unsigned char)',';}
<PHP>; {return (unsigned char)';';}

<PHP>! {return (unsigned char)'!';}
<PHP>"||" {return COR;}
<PHP>"&&" {return CAND;}
<PHP>or {return POR;}
<PHP>and {return PAND;}

<PHP>"+" {return (unsigned char)'+';}
<PHP>"+=" {return PLUSAS;}
<PHP>"-" {return (unsigned char)'-';}
<PHP>"-=" {return MINUSAS;}
<PHP>"*" {return (unsigned char)'*';}
<PHP>"*=" {return MULTAS;}
<PHP>"/" {return (unsigned char)'/';}
<PHP>"/=" {return DIVAS;}
<PHP>"%" {return (unsigned char)'%';}
<PHP>"%=" {return MODAS;}
<PHP>"++" {return INC;}
<PHP>"--" {return DEC;}

<PHP>"==" {return EQ;}
<PHP>"!=" {return NEQ;}
<PHP>"<>" {return NEQ;}
<PHP>">" {return (unsigned char)'>';}
<PHP>">=" {return GEQ;}
<PHP>"<" {return (unsigned char)'<';}
<PHP>"<=" {return LEQ;}
<PHP>"===" {return TEQ;}
<PHP>"!==" {return TNEQ;}

<PHP>"=" {return (unsigned char)'=';}

<PHP>[[:SPACE:]]+ ;
<PHP>. printf("character_not_found");

%%

void beginCondition()
{
	start_condition[0] = INITIAL;
}

void addStartCondition(int condition)
{
	condition_num++;
	changeStartCondition(condition);
}

void changeStartCondition(int condition)
{
	start_condition[condition_num] = condition;
	BEGIN(condition);
}

void returnStartCondition()
{
	condition_num--;
	BEGIN(start_condition[condition_num]);
}

void debugyy(char* msg, char* txt)
{
#ifdef PHP_DEBUG
	if (msg != 0)
		printf("DEBUG: %s: [%s]\n", msg, txt);
	else
		printf("%s\n", txt);
#endif
}

void debug_clear(char* com)
{
#ifdef PHP_DEBUG
	strcpy(com, "");
#endif
}

void debug_strcat(char* com, char* txt)
{
#ifdef PHP_DEBUG
	strcat(com, txt);
#endif
}

void writeIntToUnion(char* num, char* base)
{
	yylval.intConstUnionType = strToNumber(num, base);
}

void writeBinToUnion(char* num)
{
	yylval.intConstUnionType = strToBin(num);
}

void writeCharToUnion(char* const_char)
{
	yylval.charConstUnionType = (char*)malloc(sizeof(char)*256);
	strcpy(yylval.charConstUnionType, const_char);
}

void writeIdToUnion(char* id)
{
	yylval.idUnionType = (char*)malloc(sizeof(char)*100);
	strcpy(yylval.idUnionType, id);
}

void writeHtmlToUnion(char* uhtml)
{
	yylval.htmlUnionType = (char*)malloc(sizeof(char)*512);
	strcpy(yylval.htmlUnionType, uhtml);
	strcpy(uhtml, "");
}

void printLex(char* lexemName, char* txt)
{
	printf("%s found: [%s]\n", lexemName, txt);
}

void getDocName()
{
	if ((yytext[3] == '\"') || (yytext[3] == '\''))
	{
		strcpy(docName, yytext+4);
		docName[strlen(docName)-1] = 0;
	}
	else
		strcpy(docName, yytext+3);
}

int docNameCheck(char* name, char* txt)
{
	char dName[65];
	strcpy(dName, name);
	if(!strcmp(dName, txt) || !strcmp(strcat(dName, ";"), txt))
		return 1;
	else
		return 0;
}

int strToNumber(char* num, char* base)
{
	int number;
	sscanf(num, base, &number);
	return number;
}

int strToBin(char* num)
{
	int number = 0;
	int digit = 1;
	int i;
	for (i = strlen(num)-1; i > 1; i--)
	{
		number += (num[i]-48)*digit;
		digit *= 2;
	}
	return number;
}

void strcat_code(char* lex, int code)
{
	char h[2] = {(code%256), 0};
	strcat(lex, h);
}

void strcat_strcode(char* lex, char* code)
{
	int num;
	char copy[5];
	strcpy(copy, code);
	copy[0] = '0';
	if (copy[1] == 'x')
		sscanf(copy, "%x", &num);
	else
		sscanf(copy, "%o", &num);
	strcat_code(lex, num);
}